# 查询用例总结与索引优化指南

## 概述

本文档总结了 Strapi API 的常用查询用例，并为前端开发提供索引优化建议。基于实际测试和数据结构分析，帮助前端开发者进行高效的查询优化。

## 基础信息

- **Base URL**: `http://localhost:1337/api`
- **Content-Type**: `application/json`
- **认证方式**: JWT Token / API Token

## 文章查询用例 (Articles)

### 1. 基础查询

#### 1.1 获取所有文章
```http
GET /api/articles
```

**索引建议**: 
- ✅ `publishedAt` (时间排序)
- ✅ `createdAt` (创建时间)
- ✅ `updatedAt` (更新时间)

**性能优化**:
- 默认按 `publishedAt` 降序排列
- 建议设置合理的分页大小 (10-25条)

#### 1.2 分页查询
```http
GET /api/articles?pagination[page]=1&pagination[pageSize]=10
```

**索引建议**:
- ✅ `publishedAt` (主排序字段)
- ✅ `id` (唯一标识)

**性能优化**:
- 使用 `withCount=true` 时注意性能影响
- 建议缓存分页结果

### 2. 过滤查询

#### 2.1 按语言过滤
```http
GET /api/articles?filters[language][$eq]=ja
GET /api/articles?filters[language][$in]=ja,en,zh
```

**索引建议**:
- 🔥 **高优先级**: `language` (枚举字段，查询频繁)
- ✅ `publishedAt` (配合排序)

**性能优化**:
- 语言过滤是最常用的查询条件
- 建议在数据库层面建立复合索引: `(language, publishedAt)`

#### 2.2 按标题搜索
```http
GET /api/articles?filters[title][$contains]=strapi
GET /api/articles?filters[title][$containsi]=strapi
```

**索引建议**:
- 🔥 **高优先级**: `title` (全文搜索)
- 考虑使用全文索引或搜索引擎

**性能优化**:
- 避免在 `title` 字段上使用 `$contains` 进行大量数据查询
- 建议使用 `$containsi` (不区分大小写) 提高用户体验

#### 2.3 按标签过滤
```http
GET /api/articles?filters[tags][$contains]=数学
GET /api/articles?filters[tags][$containsi]=数学
```

**索引建议**:
- 🔥 **高优先级**: `tags` (JSON字段，需要特殊处理)
- 考虑使用专门的标签索引表

**性能优化**:
- JSON字段查询性能较低，建议限制结果数量
- 考虑将标签提取为独立的关系表

#### 2.4 按作者过滤
```http
GET /api/articles?filters[author][id][$eq]=1
GET /api/articles?filters[author][username][$eq]=author1
```

**索引建议**:
- ✅ `author` (关联字段)
- ✅ `author.id` (外键索引)

**性能优化**:
- 关联查询需要JOIN操作，建议限制结果数量
- 考虑预加载作者信息

#### 2.5 按域名过滤
```http
GET /api/articles?filters[domain][$eq]=https://16to10.com
```

**索引建议**:
- 🔥 **高优先级**: `domain` (唯一字段，查询频繁)
- ✅ `publishedAt` (配合排序)

**性能优化**:
- 域名过滤通常用于多站点场景
- 建议建立复合索引: `(domain, publishedAt)`

#### 2.6 按发布时间范围过滤
```http
GET /api/articles?filters[publishedAt][$gte]=2023-01-01
GET /api/articles?filters[publishedAt][$lte]=2023-12-31
```

**索引建议**:
- 🔥 **高优先级**: `publishedAt` (时间范围查询)
- ✅ `language` (配合其他过滤条件)

**性能优化**:
- 时间范围查询性能良好
- 建议结合其他过滤条件使用

### 3. 排序查询

#### 3.1 按时间排序
```http
GET /api/articles?sort=publishedAt:desc
GET /api/articles?sort=createdAt:desc
GET /api/articles?sort=updatedAt:desc
```

**索引建议**:
- 🔥 **高优先级**: `publishedAt` (主要排序字段)
- ✅ `createdAt` (创建时间排序)
- ✅ `updatedAt` (更新时间排序)

#### 3.2 按标题排序
```http
GET /api/articles?sort=title:asc
```

**索引建议**:
- ✅ `title` (字符串排序)
- 注意国际化排序规则

#### 3.3 多字段排序
```http
GET /api/articles?sort[0]=language:asc&sort[1]=publishedAt:desc
```

**索引建议**:
- 🔥 **高优先级**: 复合索引 `(language, publishedAt)`
- 按照排序字段顺序建立索引

### 4. 关联查询

#### 4.1 预加载作者信息
```http
GET /api/articles?populate=author
```

**索引建议**:
- ✅ `author` (外键索引)
- ✅ `author.id` (主键索引)

**性能优化**:
- 避免深度嵌套的关联查询
- 考虑使用字段选择减少数据传输

#### 4.2 预加载封面图片
```http
GET /api/articles?populate=coverImage
```

**索引建议**:
- ✅ `coverImage` (媒体字段索引)

### 5. 字段选择

#### 5.1 选择特定字段
```http
GET /api/articles?fields[0]=title&fields[1]=description&fields[2]=publishedAt
```

**性能优化**:
- 减少网络传输量
- 提高查询性能

### 6. 复合查询示例

#### 6.1 多条件组合查询
```http
GET /api/articles?filters[language][$eq]=ja&filters[domain][$eq]=https://16to10.com&filters[publishedAt][$gte]=2023-01-01&sort=publishedAt:desc&pagination[page]=1&pagination[pageSize]=10&populate=author
```

**索引建议**:
- 🔥 **高优先级**: 复合索引 `(language, domain, publishedAt)`
- ✅ `author` (关联索引)

**性能优化**:
- 这是最常用的查询模式
- 建议建立专门的复合索引

#### 6.2 搜索和过滤组合
```http
GET /api/articles?filters[title][$containsi]=数学&filters[language][$eq]=ja&sort=publishedAt:desc
```

**索引建议**:
- 🔥 **高优先级**: `language` (过滤条件)
- ✅ `publishedAt` (排序字段)
- ⚠️ `title` (全文搜索，性能较低)

## 作者查询用例 (Authors)

### 1. 基础查询

#### 1.1 获取所有作者
```http
GET /api/authors
```

**索引建议**:
- ✅ `createdAt` (时间排序)
- ✅ `username` (唯一标识)

#### 1.2 按用户名查询
```http
GET /api/authors?filters[username][$eq]=author1
```

**索引建议**:
- 🔥 **高优先级**: `username` (唯一字段，查询频繁)

#### 1.3 按显示名称查询
```http
GET /api/authors?filters[displayName][$contains]=作者
```

**索引建议**:
- ✅ `displayName` (字符串搜索)

### 2. 关联查询

#### 2.1 预加载文章列表
```http
GET /api/authors?populate=articles
```

**索引建议**:
- ✅ `articles` (关联字段)
- ⚠️ 注意N+1查询问题

## 索引优化建议

### 1. 高优先级索引

#### 文章表 (articles)
```sql
-- 主要复合索引
CREATE INDEX idx_articles_language_published ON articles(language, publishedAt DESC);
CREATE INDEX idx_articles_domain_published ON articles(domain, publishedAt DESC);
CREATE INDEX idx_articles_language_domain_published ON articles(language, domain, publishedAt DESC);

-- 单字段索引
CREATE INDEX idx_articles_published_at ON articles(publishedAt DESC);
CREATE INDEX idx_articles_created_at ON articles(createdAt DESC);
CREATE INDEX idx_articles_updated_at ON articles(updatedAt DESC);
CREATE INDEX idx_articles_title ON articles(title);
CREATE INDEX idx_articles_slug ON articles(slug);
CREATE INDEX idx_articles_author_id ON articles(author_id);

-- 全文索引 (如果支持)
CREATE FULLTEXT INDEX idx_articles_title_fulltext ON articles(title);
CREATE FULLTEXT INDEX idx_articles_content_fulltext ON articles(content);
```

#### 作者表 (authors)
```sql
-- 主要索引
CREATE INDEX idx_authors_username ON authors(username);
CREATE INDEX idx_authors_email ON authors(email);
CREATE INDEX idx_authors_created_at ON authors(createdAt DESC);
```

### 2. 查询性能优化

#### 2.1 分页优化
```javascript
// 推荐的分页查询
const getArticles = async (page = 1, pageSize = 10, filters = {}) => {
  const params = new URLSearchParams({
    'pagination[page]': page,
    'pagination[pageSize]': pageSize,
    'pagination[withCount]': 'true',
    ...filters
  });
  
  return fetch(`/api/articles?${params}`);
};
```

#### 2.2 缓存策略
```javascript
// 建议的缓存策略
const cacheConfig = {
  // 文章列表缓存 5 分钟
  articles: { ttl: 300 },
  // 单篇文章缓存 30 分钟
  article: { ttl: 1800 },
  // 作者信息缓存 1 小时
  author: { ttl: 3600 }
};
```

#### 2.3 查询限制
```javascript
// 推荐的查询限制
const queryLimits = {
  maxPageSize: 50,        // 最大分页大小
  maxSearchLength: 100,   // 最大搜索长度
  maxTagsCount: 10,       // 最大标签数量
  maxPopulateDepth: 2     // 最大关联深度
};
```

### 3. 监控指标

#### 3.1 性能指标
- 查询响应时间 < 200ms
- 数据库连接池使用率 < 80%
- 缓存命中率 > 85%

#### 3.2 慢查询监控
```sql
-- 监控慢查询
SELECT 
  query,
  avg_time,
  calls,
  total_time
FROM pg_stat_statements 
WHERE avg_time > 1000  -- 超过1秒的查询
ORDER BY avg_time DESC;
```

## 前端查询最佳实践

### 1. 查询构建器
```javascript
class QueryBuilder {
  constructor(baseUrl = '/api') {
    this.baseUrl = baseUrl;
    this.params = new URLSearchParams();
  }
  
  // 添加过滤条件
  filter(field, operator, value) {
    this.params.append(`filters[${field}][${operator}]`, value);
    return this;
  }
  
  // 添加排序
  sort(field, direction = 'asc') {
    this.params.append('sort', `${field}:${direction}`);
    return this;
  }
  
  // 添加分页
  paginate(page, pageSize) {
    this.params.append('pagination[page]', page);
    this.params.append('pagination[pageSize]', pageSize);
    return this;
  }
  
  // 添加关联
  populate(relations) {
    if (Array.isArray(relations)) {
      relations.forEach((rel, index) => {
        this.params.append(`populate[${index}]`, rel);
      });
    } else {
      this.params.append('populate', relations);
    }
    return this;
  }
  
  // 构建URL
  build(endpoint) {
    return `${this.baseUrl}${endpoint}?${this.params.toString()}`;
  }
}

// 使用示例
const query = new QueryBuilder()
  .filter('language', '$eq', 'ja')
  .filter('domain', '$eq', 'https://16to10.com')
  .sort('publishedAt', 'desc')
  .paginate(1, 10)
  .populate(['author'])
  .build('/articles');
```

### 2. 缓存管理
```javascript
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.ttl = new Map();
  }
  
  set(key, value, ttl = 300000) { // 默认5分钟
    this.cache.set(key, value);
    this.ttl.set(key, Date.now() + ttl);
  }
  
  get(key) {
    if (this.ttl.get(key) < Date.now()) {
      this.cache.delete(key);
      this.ttl.delete(key);
      return null;
    }
    return this.cache.get(key);
  }
  
  clear() {
    this.cache.clear();
    this.ttl.clear();
  }
}
```

### 3. 错误处理
```javascript
class APIError extends Error {
  constructor(message, status, details) {
    super(message);
    this.name = 'APIError';
    this.status = status;
    this.details = details;
  }
}

const handleAPIResponse = async (response) => {
  if (!response.ok) {
    const error = await response.json();
    throw new APIError(
      error.error?.message || 'API请求失败',
      error.error?.status || response.status,
      error.error?.details
    );
  }
  return response.json();
};
```

## 总结

### 关键索引优先级
1. 🔥 **最高优先级**: `language`, `domain`, `publishedAt` 复合索引
2. 🔥 **高优先级**: `title` 全文索引, `username` 唯一索引
3. ✅ **中优先级**: 单字段时间索引, 外键索引
4. ⚠️ **低优先级**: JSON字段索引 (性能较低)

### 查询优化要点
1. 优先使用索引字段进行过滤
2. 合理设置分页大小 (10-25条)
3. 避免深度关联查询
4. 使用字段选择减少数据传输
5. 实施适当的缓存策略

### 监控重点
1. 查询响应时间
2. 数据库连接使用率
3. 缓存命中率
4. 慢查询识别

通过遵循这些建议，可以显著提高API查询性能和用户体验。
